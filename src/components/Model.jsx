/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 dune01.glb 
*/

import React, { useEffect, useRef } from 'react';
import { useGLTF, PerspectiveCamera } from '@react-three/drei';
import { loadCurveFromJSON } from '../utils/curveTools/CurveMethods';
import { useFrame, useThree } from '@react-three/fiber';
import gsap from 'gsap';

const lookAtPosition = {
  x: 0,
  y: 9.178959846496582,
  z: 0,
};
const cameraStartPosition = {
  x: 0,
  y: 9.178959846496582,
  z: 25.205183029174805,
};
export function Model(props) {
  const { nodes, materials } = useGLTF('/assets/models/dune01.glb');
  const { camera } = useThree();
  const sphere = useRef(null);
  const scrollProgress = useRef(0);
  const pathData = useRef(null);

  useEffect(() => {
    const loadData = async () => {
      const JSONPath = '/assets/models/cameraPosition.json';
      const data = await loadCurveFromJSON(JSONPath);
      const curvePosition = nodes.cameraPosition.position;
      data.mesh.position.set(curvePosition.x, curvePosition.y, curvePosition.z);
      // scene.add(data.mesh);
      pathData.current = data;
    };
    loadData();
  }, []);

  useEffect(() => {
    const handleScroll = (e) => {
      scrollProgress.current =
        window.scrollY / (document.body.scrollHeight - window.innerHeight);
    };
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  useEffect(() => {
    camera.lookAt(lookAtPosition.x, lookAtPosition.y, lookAtPosition.z);
    camera.position.set(
      cameraStartPosition.x,
      cameraStartPosition.y,
      cameraStartPosition.z + scrollProgress.current * 10
    );
  }, [camera]);

  useFrame((state, delta) => {
    // const clock = state.clock;

    if (pathData.current) {
      const curve = pathData.current.curve;
      const point = curve.getPoint(scrollProgress.current);
      // points are relative to curve global position so we need to add the camera position
      point.add(cameraStartPosition);

      gsap.to(camera.position, {
        x: point.x,
        y: point.y,
        z: point.z,
        duration: 0.5,
      });
      camera.lookAt(lookAtPosition.x, lookAtPosition.y, lookAtPosition.z);
    }

    // move sphere up and down using sin wave and time
    sphere.current.position.y =
      Math.sin(state.clock.elapsedTime * 1) * 0.75 + 9.163;
  });

  return (
    <group {...props} dispose={null}>
      <PerspectiveCamera
        makeDefault={true}
        far={1000}
        near={0.1}
        fov={80}
        // fov={71.75}
        // rotation={[Math.PI / 2, 0, -Math.PI]}
        position={[0, 9.178959846496582, 25.205183029174805]}
      />
      <mesh
        ref={sphere}
        geometry={nodes.Sphere_Baked.geometry}
        material={materials.Sphere_Baked}
        position={[0, 9.163, 0]}
        scale={1.501}
      />
      <mesh
        geometry={nodes.Box_Baked.geometry}
        material={materials.box_Baked}
      />
      <mesh
        geometry={nodes.Base_Baked.geometry}
        material={materials.box_Baked}
      />
    </group>
  );
}

useGLTF.preload('/assets/models/dune01.glb');
